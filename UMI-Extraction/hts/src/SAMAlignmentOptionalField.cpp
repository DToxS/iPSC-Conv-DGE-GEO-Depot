//
//  SAMAlignmentOptionalField.cpp
//  High-Throughput-Sequencing
//
//  Created by Yuguang Xiong on 3/16/18.
//  Copyright Â© 2018 Granville Xiong. All rights reserved.
//

#include <regex>
#include <utility>
#include <sstream>
#include <iostream>
#include <stdexcept>
#include <utk/StringUtils.hpp>
#include <hts/SAMAlignmentOptionalField.hpp>

namespace hts
{

/// Initialization of standard tags and types of optional fields of SAM alignment
/// format.
const SAMAlignmentOptionalField::SAMAlignmentOptionalFieldTagTypes SAMAlignmentOptionalField::std_sam_align_opt_field_tag_types =
{
    {"AM", 'i'}, // The smallest template-independent mapping quality of segments in the rest
    {"AS", 'i'}, // Alignment score generated by aligner
    {"BC", 'Z'}, // Barcode sequence identifying the sample
    {"BQ", 'Z'}, // Offset to base alignment quality (BAQ)
    {"BZ", 'Z'}, // Phred quality of the unique molecular barcode bases in the OX tag
    {"CC", 'Z'}, // Reference name of the next hit
    {"CM", 'i'}, // Edit distance between the color sequence and the color reference (see also NM)
    {"CO", 'Z'}, // Free-text comments
    {"CP", 'i'}, // Leftmost coordinate of the next hit
    {"CQ", 'Z'}, // Color read base qualities
    {"CS", 'Z'}, // Color read sequence
    {"CT", 'Z'}, // Complete read annotation tag, used for consensus annotation dummy features
    {"E2", 'Z'}, // The 2nd most likely base calls
    {"FI", 'i'}, // The index of segment in the template
    {"FS", 'Z'}, // Segment suffix
    {"FZ", 'B'}, // Flow signal intensities
    {"GC", '\0'}, // Reserved for backwards compatibility reasons
    {"GQ", '\0'}, // Reserved for backwards compatibility reasons
    {"GS", '\0'}, // Reserved for backwards compatibility reasons
    {"H0", 'i'}, // Number of perfect hits
    {"H1", 'i'}, // Number of 1-difference hits (see also NM)
    {"H2", 'i'}, // Number of 2-difference hits
    {"HI", 'i'}, // Query hit index
    {"IH", 'i'}, // Number of stored alignments in SAM that contains the query in the current record
    {"LB", 'Z'}, // Library
    {"MC", 'Z'}, // CIGAR string for mate/next segment
    {"MD", 'Z'}, // String for mismatching positions
    {"MF", '\0'}, // Reserved for backwards compatibility reasons
    {"MI", 'Z'}, // Molecular identifier; a string that uniquely identifies the molecule from which the record was derived
    {"MQ", 'i'}, // Mapping quality of the mate/next segment
    {"NH", 'i'}, // Number of reported alignments that contains the query in the current record
    {"NM", 'i'}, // Edit distance to the reference
    {"OC", 'Z'}, // Original CIGAR
    {"OP", 'i'}, // Original mapping position
    {"OQ", 'Z'}, // Original base quality
    {"OX", 'Z'}, // Original unique molecular barcode bases
    {"PG", 'Z'}, // Program
    {"PQ", 'i'}, // Phred likelihood of the template
    {"PT", 'Z'}, // Read annotations for parts of the padded read sequence
    {"PU", 'Z'}, // Platform unit
    {"Q2", 'Z'}, // Phred quality of the mate/next segment sequence in the R2 tag
    {"QT", 'Z'}, // Phred quality of the sample-barcode sequence in the BC (or RT) tag
    {"QX", 'Z'}, // Quality score of the unique molecular identifier in the RX tag
    {"R2", 'Z'}, // Sequence of the mate/next segment in the template
    {"RG", 'Z'}, // Read group
    {"RT", 'Z'}, // Barcode sequence (deprecated; use BC instead)
    {"RX", 'Z'}, // Sequence bases of the (possibly corrected) unique molecular identifier
    {"SA", 'Z'}, // Other canonical alignments in a chimeric alignment
    {"SM", 'i'}, // Template-independent mapping quality
    {"SQ", '\0'}, // Reserved for backwards compatibility reasons
    {"S2", '\0'}, // Reserved for backwards compatibility reasons
    {"TC", 'i'}, // The number of segments in the template
    {"U2", 'Z'}, // Phred probability of the 2nd call being wrong conditional on the best being wrong
    {"UQ", 'i'} // Phred likelihood of the segment, conditional on the mapping being correct
};

/// Initialization of standard tags of optional fields of SAM alignment format.
const std::string SAMAlignmentOptionalField::std_sam_align_opt_field_tag_regex = {"[A-Za-z][A-Za-z0-9]"};

/// Initialization of standard types and value regex of optional fields of SAM
/// alignment format.
const SAMAlignmentOptionalField::SAMAlignmentOptionalFieldTypeValueRegexes SAMAlignmentOptionalField::std_sam_align_opt_field_type_value_regexes =
{
    {'A', "[!-~]"}, // Printable character
    {'i', "[-+]?[0-9]+"}, // Signed integer
    {'f', "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?"}, // Single-precision floating number
    {'Z', "[ !-~]*"}, // Printable string, including space
    {'H', "([0-9A-F][0-9A-F])*"}, // Byte array in the Hex format
    {'B', "[cCsSiIf](,[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+"} // Integer or numeric array
};

/// Default initializer.
SAMAlignmentOptionalField::SAMAlignmentOptionalField() {}

/// Initialize optional field with tag, type, and value.
SAMAlignmentOptionalField::SAMAlignmentOptionalField(const std::string& tag, char type, const std::string& value, bool parse_tag, bool parse_type, bool parse_value, bool flush_ostream) : tag{tag}, type{type}, value{value}, parse_field{false}, parse_tag{parse_tag}, parse_type{parse_type}, parse_value{parse_value}, flush_ostream{flush_ostream}
{
    // Generate the field.
    field = tag + colon_sep + type + colon_sep + value;
    // Parse tag, type, and value of optional field.
    parseParts();
}

/// Initialize optional field with tag, type, and value.
SAMAlignmentOptionalField::SAMAlignmentOptionalField(std::string&& tag, char type, std::string&& value, bool parse_tag, bool parse_type, bool parse_value, bool flush_ostream) : tag{std::move(tag)}, type{type}, value{std::move(value)}, parse_field{false}, parse_tag{parse_tag}, parse_type{parse_type}, parse_value{parse_value}, flush_ostream{flush_ostream}
{
    // Generate field.
    field = tag + colon_sep + type + colon_sep + value;
    // Parse tag, type, and value of optional field.
    parseParts();
}

/// Initialize optional field with entire field string.
SAMAlignmentOptionalField::SAMAlignmentOptionalField(const std::string& field, bool parse_field, bool parse_tag, bool parse_type, bool parse_value, bool flush_ostream) : field{field}, parse_field{parse_field}, parse_tag{parse_tag}, parse_type{parse_type}, parse_value{parse_value}, flush_ostream{flush_ostream}
{
    // Parse field and assign tag, type, and value.
    if(parse_field) parseField();
        // Parse tag, type, and value of optional field.
        parseParts();
}

/// Initialize optional field with entire field string.
SAMAlignmentOptionalField::SAMAlignmentOptionalField(std::string&& field, bool parse_field, bool parse_tag, bool parse_type, bool parse_value, bool flush_ostream) : field{std::move(field)}, parse_field{parse_field}, parse_tag{parse_tag}, parse_type{parse_type}, parse_value{parse_value}, flush_ostream{flush_ostream}
{
    // Parse field and assign tag, type, and value.
    if(parse_field) parseField();
    // Parse tag, type, and value of optional field.
    parseParts();
}

SAMAlignmentOptionalField::SAMAlignmentOptionalField(const SAMAlignmentOptionalField& opt_field) : field{opt_field.field}, tag{opt_field.tag}, type{opt_field.type}, value{opt_field.value}, parse_field{opt_field.parse_field}, parse_tag{opt_field.parse_tag}, parse_type{opt_field.parse_type}, parse_value{opt_field.parse_value}, flush_ostream{opt_field.flush_ostream} {}

SAMAlignmentOptionalField::SAMAlignmentOptionalField(SAMAlignmentOptionalField&& opt_field) : field{std::move(opt_field.field)}, tag{std::move(opt_field.tag)}, type{opt_field.type}, value{std::move(opt_field.value)}, parse_field{opt_field.parse_field}, parse_tag{opt_field.parse_tag}, parse_type{opt_field.parse_type}, parse_value{opt_field.parse_value}, flush_ostream{opt_field.flush_ostream}
{
    opt_field.reset();
}

SAMAlignmentOptionalField::~SAMAlignmentOptionalField() noexcept {}

SAMAlignmentOptionalField& SAMAlignmentOptionalField::operator=(const SAMAlignmentOptionalField& opt_field)
{
    if(this != &opt_field)
    {
        field = opt_field.field;
        tag = opt_field.tag;
        type = opt_field.type;
        value = opt_field.value;
        parse_field = opt_field.parse_field;
        parse_tag = opt_field.parse_tag;
        parse_type = opt_field.parse_type;
        parse_value = opt_field.parse_value;
        flush_ostream = opt_field.flush_ostream;
    }
    return *this;
}

SAMAlignmentOptionalField& SAMAlignmentOptionalField::operator=(SAMAlignmentOptionalField&& opt_field)
{
    if(this != &opt_field)
    {
        field = std::move(opt_field.field);
        tag = std::move(opt_field.tag);
        type = opt_field.type;
        value = std::move(opt_field.value);
        parse_field = opt_field.parse_field;
        parse_tag = opt_field.parse_tag;
        parse_type = opt_field.parse_type;
        parse_value = opt_field.parse_value;
        flush_ostream = opt_field.flush_ostream;
        opt_field.reset();
    }
    return *this;
}

/// Clear all data members.
void SAMAlignmentOptionalField::reset()
{
    field.clear();
    tag.clear();
    type = '\0';
    value.clear();
    parse_field = false;
    parse_tag = false;
    parse_type = false;
    parse_value = false;
    flush_ostream = false;
}

/// Parse top-level structure of optional field.
void SAMAlignmentOptionalField::parseField()
{
    std::vector<std::string> parts = utk::splitString(field, colon_sep);
    if(parts.size() == n_field_parts)
    {
        auto it = parts.cbegin();
        // Assign tag.
        tag = *(it++);
        if(tag.length() == 0)
        {
            std::ostringstream err_msg;
            err_msg << "Tag of " << field << " is empty!";
            throw std::logic_error(err_msg.str());
        }
        // Assign type.
        type = utk::convert<char>(*(it++));
        if(type == '\0')
        {
            std::ostringstream err_msg;
            err_msg << "Type of " << field << " is empty!";
            throw std::logic_error(err_msg.str());
        }
        // Assign value.
        value = *(it++);
        if(value.length() == 0)
        {
            std::ostringstream err_msg;
            err_msg << "Value of " << field << " is empty!";
            throw std::logic_error(err_msg.str());
        }
    }
    else
    {
        std::ostringstream err_msg;
        err_msg << field << " doesn't contain " << n_field_parts << " parts" << '!';
        throw std::logic_error(err_msg.str());
    }
}

/// Parse tag, type, and value of optional field.
void SAMAlignmentOptionalField::parseParts()
{
    if((!parse_field) && (parse_tag || parse_type || parse_value)) throw std::logic_error("parse_field must be true if any of parse_tag, parse_type, and parse_value is true!");
    /// Since the parsing of type depends on that of tag, it's more efficient to
    /// parse both tag and type together when needed.
    if(parse_type) parseTagType();
    else if(parse_tag) parseTag();
    if(parse_value) parseValue();
}

/// Parse the tag of optional field.
void SAMAlignmentOptionalField::parseTag()
{
    if(!tag.empty())
    {
        if(auto search = std_sam_align_opt_field_tag_types.find(tag); search == std_sam_align_opt_field_tag_types.end())
        {
            // Check if non-standard tag matches with tag pattern.
            if(std::regex tag_regex(std_sam_align_opt_field_tag_regex); !std::regex_match(tag, tag_regex))
            {
                std::ostringstream err_msg;
                err_msg << "Tag " << tag << " doesn't match with required tag pattern!";
                throw std::logic_error(err_msg.str());
            }
            else
            {
                std::cerr << "Warning: tag " << tag << " is non-standard!" << '\n';
            }
        }
    }
    else
    {
        std::ostringstream err_msg;
        err_msg << "Tag of " << field << " is empty" << '!';
        throw std::logic_error(err_msg.str());
    }
}

/// Parse the tag and type of optional field.
void SAMAlignmentOptionalField::parseTagType()
{
    if(!tag.empty())
    {
        try
        {
            // Parse the type of standard tag.
            if(char tag_type = std_sam_align_opt_field_tag_types.at(tag); tag_type != type && tag_type != '\0')
            {
                std::ostringstream err_msg;
                err_msg << "Type " << type << " doesn't match with the type of tag " << tag << '!';
                throw std::logic_error(err_msg.str());
            }
        }
        catch(const std::out_of_range& e)
        {
            // Parse the non-standard tag.
            std::cerr << "Warning: tag " << tag << " is non-standard!" << '\n';
            // Check if non-standard tag matches with tag pattern.
            if(std::regex tag_regex(std_sam_align_opt_field_tag_regex); !std::regex_match(tag, tag_regex))
            {
                std::ostringstream err_msg;
                err_msg << "Tag " << tag << " doesn't match with required tag pattern" << '!';
                throw std::logic_error(err_msg.str());
            }
            // Parse the type of non-standard tag.
            if(auto search = std_sam_align_opt_field_type_value_regexes.find(type); search == std_sam_align_opt_field_type_value_regexes.end())
            {
                std::cerr << "Warning: type " << type << " of non-standard tag " << tag << " doesn't match with any standard type!" << '\n';
            }
        }
    }
    else
    {
        std::ostringstream err_msg;
        err_msg << "Tag of " << field << " is empty" << '!';
        throw std::logic_error(err_msg.str());
    }
}

/// Parse the value of standard type for optional field.
void SAMAlignmentOptionalField::parseValue()
{
    if(!value.empty())
    {
        if(type != '\0')
        {
            if(auto search = std_sam_align_opt_field_type_value_regexes.find(type); search != std_sam_align_opt_field_type_value_regexes.end())
            {
                // Only parse the value for standard types.
                const std::string& value_regex_str = search->second;
                std::regex value_regex(value_regex_str);
                if(!std::regex_match(value, value_regex))
                {
                    std::ostringstream err_msg;
                    err_msg << value << " doesn't match with required value pattern " << value_regex_str << " of type " << type << '!';
                    throw std::logic_error(err_msg.str());
                }
            }
            else
            {
                std::cerr << "Warning: skip parsing the value of non-standard type " << type << '!' << '\n';
            }
        }
        else
        {
            std::cerr << "Warning: skip parsing the value of null type!" << '\n';
        }
    }
    else
    {
        std::ostringstream err_msg;
        err_msg << "Value of " << field << " is empty!";
        throw std::logic_error(err_msg.str());
    }
}

/// Print optional field of SAM alignment section.
std::ostream& operator<<(std::ostream& os, const SAMAlignmentOptionalField& opt_field)
{
    os << opt_field.getField();
    if(opt_field.getFlushOstream()) os.flush();
    return os;
}

}
